## 21. Intro To RxJava 系列教程 总结

Intro To RxJava 系列教程一共四个部分，第一部分介绍了为什么要使用 RxJava以及 RxJava的关键概念：

- [RxJava 教程第一部分：入门之 Why Rx](1.RxJava 教程第一部分：入门之 Why Rx.md)
- [RxJava 教程第一部分：入门之 关键的类](2.RxJava 教程第一部分：入门之 关键的类.md)
- [RxJava 教程第一部分：入门之 生命周期管理](3.RxJava 教程第一部分：入门之 生命周期管理.md)

如果看完第一部分对于为什么要使用 RxJava 和 何时使用 RxJava 还不太明白的，可以参考 RxJava 前传：

- [RxJava 前传 1](28.RxJava 前传 1.md)
- [RxJava 前传 2](29.RxJava 前传 2.md)
- [RxJava 前传 3](30.RxJava 前传 3.md)

通过第一部分，可以了解到 RxJava 其实主要应用了观察者模式的理念。在 RxJava 中主要干4件事：一、Observable 用来生产数据并把数据丢给观察者；二、Observer 用来处理 Observable 生产的数据；三、在数据从生产者到消费者的过程中，数据可以被再加工；四、可以指定在那个线程中加工数据和消费数据。

注意上面的数据不仅仅是指普通的模型数据（比如 一个数据库中对应的表），可以是任意的事件类型，只要是和时间相关的类型都可以。比如，点击UI 上的一个按钮触发的事件；访问 URL 地址返回的内容；访问数据库返回的数据 等。

文章第二部分主要介绍了对数据流（事件流）的一些常用的处理函数。

- [RxJava 教程第二部分：事件流基础之 创建数据流](http://blog.chengyunfeng.com/?p=959)
- [RxJava 教程第二部分：事件流基础之 过滤数据](http://blog.chengyunfeng.com/?p=960)
- [RxJava 教程第二部分：事件流基础之 检查数据](http://blog.chengyunfeng.com/?p=961)
- [RxJava 教程第二部分：事件流基础之 聚合](http://blog.chengyunfeng.com/?p=962)
- [RxJava 教程第二部分：事件流基础之 转换数据流](http://blog.chengyunfeng.com/?p=964)

这部分设计到如何创建一个数据流，也就是如何把传统的数据或者事件转换为 RxJava 的 Observable，比如把网络请求返回结果的功能封装为 Observable、把点击按钮的点击事件封装成 Observable 。然后就是对数据流中数据的处理，比如 一个按钮点击事件，如果用户对一个按钮快速的连续点击（国内的测试同学喜欢这么干），则在某个时间范围内，你可能只希望处理第一次点击事件，后续的点击事件都给丢弃了；这个点击按钮每一次点击都可以看做事件流中的一个事件，然后你可以使用一些过滤操作函数来把不符合要求的事件过滤掉，只处理你想要的数据。除了过滤操作以外，还可以检查数据是否满足某一个测试条件、也可以把数据流中的所有数据聚合起来、如果源来的数据流中的数据在你代码中无法直接使用，则你还可以把数据流中的数据转换为另外一种类型。

文章第三部分则介绍了对数据流更高级的处理函数。

- [RxJava 教程第三部分：驯服数据流之 副作用](http://blog.chengyunfeng.com/?p=968)
- [RxJava 教程第三部分：驯服数据流之 避免 monad](http://blog.chengyunfeng.com/?p=969)
- [RxJava 教程第三部分：驯服数据流之 高级错误处理](http://blog.chengyunfeng.com/?p=970)
- [RxJava 教程第三部分：驯服数据流之 组合数据流](http://blog.chengyunfeng.com/?p=972)
- [RxJava 教程第三部分：驯服数据流之 时间平移](http://blog.chengyunfeng.com/?p=974)
- [RxJava 教程第三部分：驯服数据流之 hot & cold Observable](http://blog.chengyunfeng.com/?p=975)
- [RxJava 教程第三部分：驯服数据流之 自定义操作函数](http://blog.chengyunfeng.com/?p=976)

如何在传统遗留代码中使用 RxJava以及数据流中的错误处理。还介绍了如何把多个数据流合并起来、如果推迟数据流中数据的发射。如果 RxJava 中提供的操作函数集合还不能满足你的要求，你还可以自定义操作函数。

文章最后一部分介绍了多线程相关的概念和如何在并发环境下使用。

- [RxJava 教程第四部分：并发 之线程调度](http://blog.chengyunfeng.com/?p=978)
- [RxJava 教程第四部分：并发 之测试](http://blog.chengyunfeng.com/?p=979)
- [RxJava 教程第四部分：并发 之意外情况处理](http://blog.chengyunfeng.com/?p=980)
- [RxJava 教程第四部分：并发 之数据流发射太快如何办](http://blog.chengyunfeng.com/?p=981)

通常情况下，生产数据的源头可能需要比较长的时间去执行，比如请求一个网址，获取返回的内容。可以通过 RxJava 提供的方法把耗时的请求放到另外一个线程中执行。另外把数据从一种类型转换为另外一种类型的过程可能也是很耗时的，同样也可以指定每个操作函数在那个线程执行。还介绍了 如果生产数据的源，生产数据的速度很快，而消费者无法及时的处理这些数据该肿么办。

看完本系列教程，可以发现 RxJava 本质上只是提供了一个处理数据流的框架。

可以这样打个比方，有个生产肥皂的机器 （Observable），该机器每隔10秒生产一块肥皂（原始的数据），后面还有一个机器用来在肥皂上面印上公司 logo （操作函数，把一种数据转换为另外一种数据），在后面还有一个机器用来把肥皂放到盒子中包装起来（同样也是一个操作函数），最后有个工人（消费者）把每盒肥皂装箱打包。

而 RxJava 的方便之处就是把这个流程中的处理给简化了，并且可以像使用 Builder 模式一样串联调用，使代码看起来更加优雅。再加上还可以指定每个操作函数执行的线程，使多线程处理更加方便。

就拿前面提到的用户快速狂按一个按钮的情况来说，在原生 Android 系统里面是不认为这种情况为 bug， 比如使用原生的 Android 系统，在vpn设置界面快速点击两次添加 vpn的按钮，则可以看到添加 vpn 的对话框会打开两个，关闭一个还有另外一个存在。正常用户不会这样操作系统，就算用户这样操作了，多打开一个同样的界面其实影响也不大，用户关闭即可。 而国内的测试同学经常会测试这个情况，大家通常情况下都是在 View onClick 的时候记录下点击的时间，然后在 onClick 中比较前一次点击的时间和当前的时间，如果这个时间小于一个值（比如 1秒）就认为这次点击是无效的。添加了一个变量用来记录时间并且每次点击都要比较，只是为了处理快速点击的情况。如果使用 RxJava 则就非常简单了：

```java
RxView.clicks(button).throttleFirst(500, TimeUnit.MILLISECONDS).subscribe(…);
```

只处理 500ms 内的第一次点击。 一旦你掌握了 RxJava，发现使用 Rx 的方式来思考问题和解决问题写出的代码是如此的优雅。
